\documentclass{llncs}
\usepackage{multirow}
\usepackage{fancyvrb}
\usepackage{tikz}
\usepackage{tikz-timing}
%

\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\small}

\begin{document}

\title{What's the Matter with Kansas Lava?}
\subtitle{Extended Abstract}

\author{Andrew Farmer \and Garrin Kimmell \and Andy Gill}

\institute{
Information Technology and Telecommunication Center \\
Department of Electrical Engineering and Computer Science \\
The University of Kansas \\
2335 Irving Hill Road \\
Lawrence, KS 66045 \\
\email{\{anfarmer,kimmell,andygill\}@ku.edu}}

\maketitle

\begin{abstract}
Kansas Lava is a functional hardware description language implemented
in Haskell. In the course of attempting to generate ever larger circuits,
we have found the need to effectively test and debug the internals of
Kansas Lava. This includes confirming both the simulated behavior of the
circuit and its hardware realization via generated VHDL. In
this paper we share a few of our approaches to this problem, and discuss
the results of these efforts.
\end{abstract}

\section{Introduction}

\subsection{What is Kansas Lava?}

Kansas Lava is an effort to create a modern implementation of the Lava
design pattern that allows direct (Chalmers style) specification of circuits.

There are two concrete types in Kansas Lava: \verb!Seq! and \verb!Comb!, which represent
sequential and combinatorial values, respectively. Combinatorial values exclude the
notion of a clock, whereas sequential values are more like streams in that they
encode a series of values over time. Both are instances of the \verb!Signal! type class,
over which most primitives are defined.
This allows the user to write circuits that work on both types of input, pretending
there is a single unified type, \verb!Signal!.

Kansas Lava supports both simulation and synthesis of circuits by having a dual
shallow and deep embedding within \verb!Signal!. The deep embedding is a
structure of primitive entities that can be reified to a netlist, from which
we generate VHDL for compilation.

\subsection{In This Paper}

Programmatically generating hardware presents new challenges when it comes
to testing and debugging. Often, traditional lightweight testing strategies
are cumbersome to use in large circuits, or don't permit inspection of
intermediate values.

In this paper we present four approaches to testing and debugging
Lava circuits. They enable us to scale Lava usage to large, real-world
problem instances in a more straightforward manner than in the past.
We summarize each approach here, noting which embedding and
circuit type can be tested, as well as the target use case:

% TODO: Make sure this is correct
\begin{center}
\label{table:approaches}
\begin{tabular}{l | c | c | c | c | c | c |}
\cline{2-5}
& \multicolumn{2}{|c|}{Embedding}
& \multicolumn{2}{c|}{Circuit Type}
& \multicolumn{1}{|c}{}\\
\cline{2-6}
 & Shallow & Deep & Comb & Seq & Use Case \\
\hline
\multicolumn{1}{|c|}{QuickCheck} & \multirow{2}{*}{Y} & \multirow{2}{*}{N} & \multirow{2}{*}{Y} & \multirow{2}{*}{N} & \multirow{2}{*}{Users} \\
\multicolumn{1}{|c|}{\footnotesize{Section \ref{sec:quickcheck}}} & & & & & \\
\hline
\multicolumn{1}{|c|}{Truth Tables} & \multirow{2}{*}{Y} & \multirow{2}{*}{N} & \multirow{2}{*}{Y} & \multirow{2}{*}{Y} & \multirow{2}{*}{Users} \\
\multicolumn{1}{|c|}{\footnotesize{Section \ref{sec:waveforms}}} & & & & & \\
\hline
\multicolumn{1}{|c|}{Probes} & \multirow{2}{*}{Y} & \multirow{2}{*}{Y} & \multirow{2}{*}{Y} & \multirow{2}{*}{Y} & \multirow{2}{*}{Both} \\
\multicolumn{1}{|c|}{\footnotesize{Section \ref{sec:probes}}} & & & & & \\
\hline
\multicolumn{1}{|c|}{Automated Comparison} & \multirow{2}{*}{Y} & \multirow{2}{*}{Y} & \multirow{2}{*}{Y} & \multirow{2}{*}{Y} & \multirow{2}{*}{KL Devs} \\
\multicolumn{1}{|c|}{\footnotesize{Section \ref{sec:comparing}}} & & & & & \\
\hline
\end{tabular}

% took this out of a table \caption{Something}

\end{center}

\section{Using QuickCheck}
\label{sec:quickcheck}

A popular method of testing Haskell functions is to use the QuickCheck library.
Since Lava circuits are Haskell functions, this is straightforward.
For instance, given Kansas Lava's implementation of boolean conjunction and
a suitable instance of QuickCheck's Arbitrary type class:

\begin{code}
and2 :: (Signal sig) => sig Bool -> sig Bool -> sig Bool
and2 = liftS2 $ \ (Comb a ae) (Comb b be) ->
                    Comb (liftA2 (&&) a b)
                       $ entity2 (Name "Bool" "and2") ae be

instance (Arbitrary a, Wire a) => Arbitrary (Comb a) where
    arbitrary = shallowComb <$> (optX :: Maybe a -> X a) <$> arbitrary
\end{code}

One can verify properties like the following, which shows that the
\verb|and2| implementation is commutative:

\begin{code}
prop_andComm x y = (x `and2` y) == (y `and2` x)
    where types = (x :: Comb Bool, y :: Comb Bool)
\end{code}

While this approach is quick and easy to implement, it is of
limited use.

The most immediate problem is that equality over sequential
inputs is effectively undefined. While two sequences can certainly
be unequal, their unbounded nature makes it impossible to be
certain they are truly equivalent, rather than merely having
equivalent prefixes. We can use a hack to say, effectively, that
the first $n$ values are 'good enough':

\begin{code}
prop_andCommSeq x y = show (x `and2` y) == show (y `and2` x)
    where types = (x :: Seq Bool, y :: Seq Bool)
\end{code}

But this is less than ideal. An instance of QuickCheck's Arbitrary
type class is nevertheless defined for \verb!Seq!, in case it proves
useful for other kinds of tests.

More problematic is the fact that using QuickCheck doesn't test the deep
embedding at all. The instance that defines equality between
Comb values only compares the shallow embeddings. It is
not obvious how to define equality over the deep embedding,
short of comparing the resulting circuit graphs for isomorphism.
The worst case complexity of such a solution would be exponential.

As long as end users of Kansas Lava are building circuits out
of the supplied primitives, they shouldn't have to worry about
the deep embedding at all, so QuickCheck may prove to be an
effective tool for small circuits. For larger circuits that
require non-random inputs, another solution is needed.

\section{Generating Truth Tables and Waveforms}
\label{sec:waveforms}

An easy way to visualize the relationship between circuit inputs and
outputs is by generating truth tables, which can then be transformed
into waveform diagrams. For a combinatorial circuit, all possible
values for each input are permuted and the circuit is applied to each
permutation in turn, storing the result in a treelike structure.

This also works for sequential circuits. Using a small DSL to apply the sequential
circuit to sample inputs, we stash both the function and its arguments
in a data structure as they are applied in succession:

\begin{code}
tt = truthTable (example (xor2 :: Seq Bool -> Seq Bool -> Seq Bool)
                .*. input1
                .*. input2)
        where
                input1 = encSeqBool "HLHHL"
                input2 = encSeqBool "HH_LL"
\end{code}

Implementing this is straightforward. The \verb!example! function simply
wraps up its argument (the circuit) for the \verb!.*.! operator, which applies
each argument in succession, storing it for later inclusion in the table. 
\emph{In the final paper, we detail the implementation of these two functions here.}

All that remains is to pretty print the resulting truth table.
Currently we can output both ASCII and \LaTeX \hspace{1pt} tables, as well as \LaTeX \hspace{1pt} waveforms.
An example waveform for a mux can be found in Figure 1. % for some reason this returns 3?! \ref{fig:mux2}.
% is the use of the latex logo above totally retarded?

\begin{figure}
\label{fig:mux2}
\centering
\begin{tikztimingtable}
s0 & 1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U\\
i0 & 1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U\\
i1 & 1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U\\
o0 & 1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U\\
\end{tikztimingtable}

\caption{\tt mux2 :: Comb Bool $\to$ (Comb Bool, Comb Bool) $\to$ Comb Bool}
\end{figure}

Using this approach, it is easy to visualize the relationship
between inputs and outputs. In the case of sequential circuits, it is also
helpful to see \emph{when} things happen. As such, we intend to use it
extensively to document the behavior of Kansas Lava primitives for end users.

It also addresses one of the issues we had with QuickCheck, in that we have
control over the exact input that is used to test the circuit. This allows
us to more effectively test large circuits.

However, this approach requires direct examination by the user to verify that the
simulated circuit behaved correctly for each combination of inputs, which
is time consuming. It also doesn't test the deep embedding or permit
inspection of intermediate results inside the circuit. For larger circuits, this
ability is crucial. To address this need, we created probes, starting from the
design in the Hawk architectural design language.

\section{Circuit Instrumentation Using Probes}
\label{sec:probes}

Circuits are opaque Haskell functions which only permit
observation of the relationship between inputs and output. Intermediate
values, defined as local Haskell bindings, cannot be observed without modifying
the underlying circuit.

As a simple example, consider the archetypal Lava definition of a full adder,
constructed by combining two half adder circuits:

\begin{code}
halfAdder a b = (sum,carry)
  where sum = xor2 a b
        carry = and2 a b

fullAdder a b cin = (sum,cout)
  where (s1,c1) = halfAdder a a
        (sum,c2) = halfAdder cin s1
        cout = xor2 c1 c2
\end{code}

In this example, the intermediate values \verb!s1!, \verb!c1!, and \verb!c2! are
not exposed as outputs to the function, and are consequently not
observable. In fact, the above definition has a bug in the calculation of
\verb!(s1,c1)! where the input parameter \verb!a! is used as the second argument
to the half adder instead of the parameter \verb!b!. Observing the input/output
behavior of the \verb!fullAdder! function will reveal incorrect behavior, but it
does not provide any insight into the location of the error. Rather, we need to
be able to observe the input/output behavior of the first \verb!halfAdder!.

One approach to locating the bug is to simply return the intermediate values as
additional outputs to the circuit:

\begin{code}
fullAdder a b cin = ((sum,cout),debug)
  where (s1,c1) = halfAdder a a
        (sum,c2) = halfAdder cin s1
        cout = xor2 c1 c2
        debug = (s1,c1,c2)
\end{code}

While effective, this approach suffers in that it changes the interface to the
circuit, which in turn necessitates a modification to all of the users of the
circuit. Moreover, if the incorrect behavior were to be observed when defining a
circuit which \emph{uses} the full adder, then that circuit must in turn be
modified to propagate the debugging output of the \verb!fullAdder! circuit.

This leaves the user with two options, both with
significant drawbacks. Either \emph{all} of the intermediate circuit outputs are
exported (changing the circuit interfaces a single time) and then the global
collection of intermediate values is sorted through, or the user 
iteratively exports a subset of the intermediate values, checking for correct
behavior, until the troublesome circuit is located.

Kansas Lava provides a solution that sidesteps this time consuming process
using the notion of a \emph{probe}. When using this construct,
intermediate values can be observed without changing the circuit
interface. Moreover, only those intermediate values that are probed will be
observable, allowing probes to be inserted and removed as the circuit is
searched to locate the source of an error.

The Kansas Lava \verb!probe! function takes a string representing a
user-significant name for the intermediate value and a Kansas Lava
circuit. To allow \verb!probe! to be utilized for a variety of types, the
function is overloaded via a type class. Instances are provided for the range of
types representable as Kansas Lava circuits.

\begin{code}
class Probe a where
  probe :: String -> a -> a
\end{code}

\emph{In the full paper, we demonstrate probe usage on intermediate values
and intermediate functions, which allows us to capture inputs as well as output.
We also cover the implementation of the probe functionality, which is a
pleasant consequence of the dual-embedding nature of Kansas Lava.}

\section{Automated Comparison of Deep and Shallow}
\label{sec:comparing}

Using probes, we can compare the results of the shallow simulation
against those of the deep, compiled version of the circuit. This allows us to
confirm that the shallow and deep embeddings yield the same result.

\begin{code}
testCircuit :: (Ports a, Probe a, Ports b) =>
                String -> a -> (a -> b) -> IO ()
\end{code}

The \verb!testCircuit! function takes a circuit and
a function that applies the circuit to arguments. It simply wraps a probe around
the circuit and passes it to the second function. As an example:

\begin{code}
testCircuit "mux2" 
    (mux2 :: Seq Bool -> (Seq U4, Seq U4) -> Seq U4)
    (\ f -> let sel  = toSeq $ cycle [True,False,True,True,False]
                inp  = toSeq $ cycle [0..15]
                inp2 = toSeq $ cycle $ reverse [0..15]
            in f sel (inp, inp2))  
\end{code}

Using the data collected by the probe, we can generate input and expected output
files, along with a test bench, for a VHDL simulator. Then we test the
compiled VHDL obtained from the deep embedding and compare the results with 
a standard diff tool.

\paragraph{Ongoing work that will be expanded upon in the final paper - }
Using this basic ability to automatically compare the deep and shallow embeddings,
we can implement a form of automated algorithmic debugging, using one embedding as the
oracle for the other.

At a high level, algorithmic debugging builds an execution tree, then iteratively
checks the value of each node with one given by an oracle (often the programmer).
If the values match, the node is considered ``correct'' and the debugger continues
with that node's siblings. If the values do not match, the node is considered
``incorrect'' and the debugger instead continues with that node's children. If
all the children are in turn correct, then the node itself is at fault.

% image of sample execution tree or circuit graph

Using the netlist created by the Kansas Lava reification process, we can construct
a small execution graph, where each node represents a high level component of
the circuit and contains the probe results for that component. We then search the
graph, simulating each node and comparing it to the probe results, returning
the first incorrect node that is either has no children, or has children that
are all correct.

% need to implement this and stick some code/pictures/dot diagrams here

We hope this technique will allow us to find problems in extremely large circuits quickly.

% talk about adapting probes to execution tree/algorithmic debugging idea?

\section{Conclusion and Future Work}

Traditional Haskell testing tools like QuickCheck are of limited use
when testing Lava circuits. Many properties that are easy to express
over finite data structures (like \verb!Comb!) are more cumbersome
over unbounded ones (such as \verb!Seq!). They also present no easy
way to test generated VHDL code.

Observing the inputs and outputs to a circuit via truth tables and
waveforms helps explain circuit behavior, but doesn't permit testing
of an internal component in the context of a larger circuit. Once again,
the deep embedding is not tested at all.

Probes present a method of observing intermediate values in the shallow
embedding and recovering them for comparison with the VHDL coming out of
the deep embedding. They also serve as the foundation for more advanced 
strategies, such as our adaptation of algorithmic debugging.

While the current system is primarily useful to Kansas Lava developers to
ensure correct VHDL generation, one possible future direction is to adapt 
the current framework to be a true algorithmic debugger, with the Lava
user as the oracle. Alternatively, this framework could be used to test 
circuit optimizations, using the unoptimized circuit as an oracle for
the optimized one.

\end{document}
