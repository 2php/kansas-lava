\documentclass{llncs}
\usepackage{tikz}
\usepackage{tikz-timing}
%

\begin{document}

\title{What's the Matter with Kansas Lava?}

\author{Andrew Farmer \and Garrin Kimmell \and Andy Gill}

\institute{
Information Technology and Telecommunication Center \\
Department of Electrical Engineering and Computer Science \\
The University of Kansas \\
2335 Irving Hill Road \\
Lawrence, KS 66045 \\
\email{\{anfarmer,kimmell,andygill\}@ku.edu}}

\maketitle

\begin{abstract}
Kansas Lava is a functional hardware description language implemented
in Haskell. In the course of attempting to generate ever larger circuits,
we have found the need to effectively test and debug the internals of
Kansas Lava. This includes confirming both the simulated behavior of the
circuit and its hardware realization via generated VHDL. In
this paper we share a few of our approaches to this problem, and discuss
the results of these efforts.
\end{abstract}

\section{Introduction}

\subsection{What is Kansas Lava?}

Kansas Lava is an effort to create a modern implementation of the Lava
design pattern that allows direct (Chalmers style) specification of circuits.

There are two concrete types in Kansas Lava: \verb!Seq! and \verb!Comb!, which represent
sequential and combinatorial values, respectively. Combinatorial values exclude the
notion of a clock, whereas sequential values are more like streams in that they
encode a series of values over time.

Both are instances of the \verb!Signal! typeclass, over which most primitives are defined.
This allows the user to write circuits that work on both types of input, pretending
there is a single unified type, \verb!Signal!. As an example:

\begin{verbatim}
halfAdder a b = (carry,sum)
  where carry = and2 a b
        sum   = xor2 a b
\end{verbatim}

Notice that the \verb!halfAdder! circuit we just defined can be used with
both types of input values:

\begin{verbatim}
ghci> halfAdder (constComb True) (constComb True)                                            
(T,F)

ghci> let x = toSeq $ cycle [False,False,True,True]
ghci> let y = toSeq $ cycle [False,True]
ghci> halfAdder x y
(F :~  F :~  F :~  T :~ ..., F :~  T :~  T :~  F :~ ...)
\end{verbatim}

Kansas Lava supports both simulation and synthesis of circuits by having a dual
shallow and deep embedding within \verb!Signal!. The deep embedding is a
structure of primitive entities that can be reified to a netlist, from which
we generate VHDL for compilation.

\subsection{Techniques}

In this paper we present four approaches to testing and debugging
Lava circuits. We summarize them here, noting which embedding and
circuit type can be tested, as well as the target use case.

% TODO: Make sure this is correct, and force it to inline rather than float.
\begin{center}
\label{table:approaches}
\begin{tabular}{l | c | c | c | c | c | c |}
\cline{2-5}
& \multicolumn{2}{|c|}{Embedding}
& \multicolumn{2}{c|}{Circuit Type}
& \multicolumn{1}{|c}{}\\
\cline{2-6}
 & Shallow & Deep & Comb & Seq & Use Case \\
\hline
\multicolumn{1}{|l|}{QuickCheck} & y & n & y & n & Users \\
\hline
\multicolumn{1}{|l|}{Truth Tables} & y & n & y & y & Users \\
\hline
\multicolumn{1}{|l|}{Probes} & y & y & y & y & Both \\
\hline
\multicolumn{1}{|l|}{Comparing} & y & y & y & y & KL Devs \\
\hline
\end{tabular}

% took this out of a table \caption{Something}

\end{center}

\section{Using QuickCheck}

A popular method of testing Haskell functions is to use the QuickCheck library.
Since Lava circuits are Haskell functions, this is straightforward.
For instance, given Kansas Lava's implementation of boolean conjunction and
a suitable instance of QuickCheck's Arbitrary typeclass:

\begin{verbatim}
and2 :: (Signal sig) => sig Bool -> sig Bool -> sig Bool
and2 = liftS2 $ \ (Comb a ae) (Comb b be) ->
                    Comb (liftA2 (&&) a b)
                       $ entity2 (Name "Bool" "and2") ae be

instance (Arbitrary a, Wire a) => Arbitrary (Comb a) where
    arbitrary = shallowComb <$> (optX :: Maybe a -> X a) <$> arbitrary
\end{verbatim}

One can verify properties like the following, which shows that the
\verb|and2| implementation is commutative:

\begin{verbatim}
prop_andComm x y = (x `and2` y) == (y `and2` x)
    where types = (x :: Comb Bool, y :: Comb Bool)
\end{verbatim}

While this approach is quick and easy to implement, it is of
limited use.

The most immediate problem is that equality over sequential
inputs is effectively undefined. While two sequences can certainly
be unequal, their unbounded nature makes it impossible to be
certain they are truly equivalent, rather than merely having
equivalent prefixes. We can use a hack to say, effectively, that
the first $n$ values are 'good enough':

\begin{verbatim}
prop_andCommSeq x y = show (x `and2` y) == show (y `and2` x)
    where types = (x :: Seq Bool, y :: Seq Bool)
\end{verbatim}

But this is less than ideal. An instance of QuickCheck's Arbitrary
typeclass is nevertheless defined for Seqs, in case it proves
useful for other kinds of tests.

More problematic is the fact that using QuickCheck doesn't test the deep
embedding at all. The instance that defines equality between
Comb values only compares the shallow embeddings. It is
not obvious how to define equality over the deep embedding,
short of comparing the resulting circuit graphs for isomorphism.
The worst case complexity of such a solution would be exponential.

As long as end users of Kansas Lava are building circuits out
of the supplied primitives, they shouldn't have to worry about
the deep embedding at all, so QuickCheck may prove to be an
effective tool for small circuits. For larger circuits that
require non-random inputs, another solution is needed.

\section{Generating Truth Tables and Waveforms}

An easy way to visualize the relationship between circuit inputs and
outputs is by generating truth tables, which can then be transformed
into waveform diagrams. For a combinatorial circuit, all possible
values for each input are permuted and the circuit is applied to each
permutation in turn, storing the result in a treelike structure.

This also works for sequential circuits. Using a small DSL to apply the sequential
circuit to sample inputs, we stash both the function and its arguments
in a data structure as they are applied in succession:

\begin{verbatim}
tt = truthTable (example (xor2 :: Seq Bool -> Seq Bool -> Seq Bool)
                .*. input1
                .*. input2)
        where
                input1 = encSeqBool "HLHHL"
                input2 = encSeqBool "HH_LL"
\end{verbatim}

Implementing this is straightforward. The \verb!example! function simply
wraps up its argument (the circuit) for the \verb!.*.! operator, which applies
each argument in succession, storing it for later inclusion in the table. Both
are defined thus:

\begin{verbatim}
data Example a = Example a [ExampleArg]

data ExampleArg = forall a . (Show a, RepWire a) => ExampleArg (Seq a)

example :: a -> Example a
example a = Example a []

infixl 2 .*.

(.*.) :: TestArg a => Example (a -> b) -> a -> Example b
(.*.) (Example f args) arg = Example (f arg) (args ++ testArg arg)

class TestArg a where
    testArg :: a -> [ExampleArg]

instance (Show a, RepWire a) => TestArg (Seq a) where
    testArg a = [ExampleArg a]

instance (Show a, RepWire a) => TestArg (Comb a) where
    testArg a = [ExampleArg (liftS0 a)]
\end{verbatim}

All that remains is to pretty print the resulting truth table.
Currently we can output both ASCII and \LaTeX tables, as well as \LaTeX waveforms.
An example waveform for a mux can be found in Figure 1. % for some reason this returns 3?! \ref{fig:mux2}.
% is the use of the latex logo above totally retarded?

\begin{figure}
\label{fig:mux2}
\centering
\begin{tikztimingtable}
s0 & 1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U\\
i0 & 1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U\\
i1 & 1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U\\
o0 & 1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U\\
\end{tikztimingtable}

\caption{\tt mux2 :: Comb Bool $\to$ (Comb Bool, Comb Bool) $\to$ Comb Bool}
\end{figure}

Using this approach, it is easy to visualize the relationship
between inputs and outputs. In the case of sequential circuits, it is also
helpful to see \emph{when} things happen. As such, we intend to use it
extensively to document the behavior of Kansas Lava primitives for end users.

It also addresses one of the issues we had with QuickCheck, in that we have
control over the exact input that is used to test the circuit. This allows
us to more effectively test large circuits.

However, this approach requires direct examination by the user to verify that the
simulated circuit behaved correctly for each combination of inputs, which
is time consuming. It also doesn't test the deep embedding or permit
inspection of intermediate results inside the circuit. For larger circuits, this
ability is crucial. To address this need, we created probes.

\section{Circuit Instrumentation Using Probes}

Testing primitive circuits using the shallow embedding of Haskell provides a
convenient method for validating circuit behavior. However, as a Lava user
constructs increasingly larger components by composing primitive circuits, the shallow
embedding is of decreasing value for understanding the interaction between
those primitive components. This is due to the embedding of circuits as Haskell
values -- circuits are opaque Haskell functions with which it is only possible
to observe the relationship between inputs and function output. Intermediate
values, defined as local Haskell bindings, cannot be observed without modifying
the underlying circuit.

As a simple example, consider the archetypal Lava definition of a full adder,
constructed by combining two half adder circuits:

\begin{verbatim}
halfAdder a b = (sum,carry)
  where sum = xor2 a b
        carry = and2 a b

fullAdder a b cin = (sum,cout)
  where (s1,c1) = halfAdder a a
        (sum,c2) = halfAdder cin s1
        cout = xor2 c1 c2
\end{verbatim}

In this example, the intermediate values \verb!s1!, \verb!c1!, and \verb!c2! are
not exposed as outputs to the function, and are consequently not
obervable. In fact, the above definition has a bug in the calculation of
\verb!(s1,c1)! where the input parameter \verb!a! is used as the second argument
to the half adder instead of the parameter \verb!b!. Observing the input/output
behavior of the \verb!fullAdder! function will reveal incorrect behavior, but it
does not provide any insight into the location of the error. Rather, we need to
be able to observe the input/output behavior of the first \verb!halfAdder!.

One approach to locating the bug is to simply return the intermediate values as
additional outputs to the circuit:

\begin{verbatim}
fullAdder a b cin = ((sum,cout),debug)
  where (s1,c1) = halfAdder a a
        (sum,c2) = halfAdder cin s1
        cout = xor2 c1 c2
        debug = (s1,c1,c2)
\end{verbatim}

While effective, this approach suffers in that it changes the interface to the
circuit, which in turn necessitates a modification to all of the users of the
circuit. Moreover, if the incorrect behavior were to be observed when defining a
circuit which \emph{uses} the full adder, then that circuit must in turn be
modified to propogate the debugging output of the \verb!fullAdder! circuit.

This leaves the user with two options, both with
significant drawbacks. Either \emph{all} of the intermediate circuit outputs are
exported (changing the circuit interfaces a single time) and then the global
collection of intermediate values is sorted through. Alternatively, the user can
iteratively export a subset of the intermediate values, checking for correct
behavior, until the troublesome circuit is located.

Kansas Lava provides a solution that sidesteps this time consuming debugging
using the notion of a \emph{probe}. When using this construct,
intemediate values can be observed without changing the circuit
interface. Moreover, only those intermediate values that are probed will be
observable, allowing probes to be inserted and removed as the circuit is
searched to locate the source of an error.

The Kansas Lava \verb!probe! function takes a string representing a
user-significant name for the intermediate value, along with a Kansas Lava
circuit. To allow \verb!probe! to be utilized for a variety of types, the
function is overloaded via a type class. Instances are provided for the range of
types representable as Kansas Lava circuits.

\begin{verbatim}
class Probe a where
  probe :: String -> a -> a
\end{verbatim}

Using this function, we can instrument the \verb!fullAdder! circuit to expose
intermediate values:

\begin{verbatim}
fullAdder a b cin = (sum,cout)
  where (s1,c1) = halfAdder a a
        (sum,c2) = halfAdder cin (probe "s1" s1)
        cout = xor2 (probe "c1" c1) (probe "c2" c2)
\end{verbatim}

Kansas Lava provides two functions for extracting probe % had circuits instead of functions, is fns right?
values. First, \verb!probeCircuit! takes a circuit with probes and generates an
association list of probe names and values. The \verb!getProbe! function looks
up a probe name in this list and returns the associated value. The \verb!test!
function, shown below, demonstrates the use of these two functions.

\begin{verbatim}
test = do
  probes <- probeCircuit $ fullAdder' false false false
  case (getProbe probes "s1") of
    Just (ProbeValue probeName xstrm) -> return $ showXStream xstrm
\end{verbatim}

Calling \verb!test! at the ghci prompt yields the following trace of outputs for
the \texttt{s1} probe. 

\begin{verbatim}
ghci> test
"F" :~  "F" :~  ...
\end{verbatim}

The probe mechanism automatically lifts combinational Kansas Lava
values into a stream of values, as the probe mechanism proves particularly
useful when debugging sequential circuits.

Although the above example demonstrated a way to observe intermediate Kansas
Lava values, it doesn't necessarily shed a great deal of light on the particular
bug in the full adder circuit, which is due to providing the wrong argument to
the first halfAdder circuit, while we have only observed the output of that
function. To make it possible to observe both the input and output of a
function, we can apply probe to the function itself:

\begin{verbatim}
fullAdder a b cin = (sum,cout)
  where (s1,c1) = (probe "h1" halfAdder) a a
        (sum,c2) = halfAdder cin s1
        cout = xor2 c1 c2
\end{verbatim}


Modifying the \verb!test! function allows us to print out the traces from all of
the probes.

\begin{verbatim}
test = do
  probes <- probeCircuit $ fullAdder'' false false false
  mapM_ printProbe probes
 where printProbe (i, (ProbeValue name xstrm)) = do
          putStr $ name ++ ": "
          putStrLn $ show $ showXStream xstrm
\end{verbatim}

This modified \verb!test! function shows the traces for each of the input
arguments to the half adder, as well as the output. The \verb!probe! function
generates names for each of these by simply enumerating each argument (along
with the result) and adding the enumerated index to the given probe name, \verb!h1!.

\begin{verbatim}
ghci> test
h1_2: "(F,F)" :~  "(F,F)"  :~ ...
h1_1: "F" :~  "F" :~  ...
h1_0: "F" :~  "F" :~  ...
\end{verbatim}

\paragraph{Implementing Probe}

The ability to observe intermediate Kansas Lava values is a pleasing consequence
of maintaining both a shallow and deep embedding of Kansas Lava
circuits. When the \verb!probe! function is invoked on the circuit, the
shallowly-embedded value associated with the circuit is stored in the deep
embedding. To allow any Kansas Lava value to be stored in the deep
representation, we construct an existential type, \verb!ProbeValue!, which has a
constraint which allows us to recover the printed representation of the
value. One downside of this implementation decision is that we can no longer
manipulate observed values directly, only their string representations.

Once probed values have been added to the deep embedding representation, 
\verb!probeCircuit! reifies the circuit using the basic Kansas Lava reification
mechanism \cite{}, and the stored probe values are copied to an association
list. Reificiation is performed within the IO monad, hence the use of monadic \verb!do!
notation in the \verb!test! functions.

% XXXXXX: Andrew, you should extend this to talk about how we can use this to
% make sure that the shallow embedding agrees with our generated VHDL for the same
% circuit, using testbench framework.

\section{Comparing Deep and Shallow}

Describe, maybe show example or the info file or something?

\subsection{The Good}

Excellent for testing our VHDL generation.

\subsection{The Bad}

Not so useful to end users of Lava? Simulation can be time consuming?

% talk about adapting probes to execution tree/algorithmic debugging idea?
% conclusion?

\end{document}
