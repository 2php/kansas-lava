\documentclass{llncs}
\usepackage{multirow}
\usepackage{tikz}
\usepackage{tikz-timing}
%

\begin{document}

\title{What's the Matter with Kansas Lava?}

\author{Andrew Farmer \and Garrin Kimmell \and Andy Gill}

\institute{
Information Technology and Telecommunication Center \\
Department of Electrical Engineering and Computer Science \\
The University of Kansas \\
2335 Irving Hill Road \\
Lawrence, KS 66045 \\
\email{\{anfarmer,kimmell,andygill\}@ku.edu}}

\maketitle

\begin{abstract}
Kansas Lava is a functional hardware description language implemented
in Haskell. In the course of attempting to generate ever larger circuits,
we have found the need to effectively test and debug the internals of
Kansas Lava. This includes confirming both the simulated behavior of the
circuit and its hardware realization via generated VHDL. In
this paper we share a few of our approaches to this problem, and discuss
the results of these efforts.
\end{abstract}

\section{Introduction}

\subsection{What is Kansas Lava?}

Kansas Lava is an effort to create a modern implementation of the Lava
design pattern that allows direct (Chalmers style) specification of circuits.

There are two concrete types in Kansas Lava: \verb!Seq! and \verb!Comb!, which represent
sequential and combinatorial values, respectively. Combinatorial values exclude the
notion of a clock, whereas sequential values are more like streams in that they
encode a series of values over time.

Both are instances of the \verb!Signal! typeclass, over which most primitives are defined.
This allows the user to write circuits that work on both types of input, pretending
there is a single unified type, \verb!Signal!. As an example:

\begin{verbatim}
halfAdder a b = (carry,sum)
  where carry = and2 a b
        sum   = xor2 a b
\end{verbatim}

Notice that the \verb!halfAdder! circuit we just defined can be used with
both types of input values:

\begin{verbatim}
ghci> halfAdder (constComb True) (constComb True)                                            
(T,F)

ghci> let x = toSeq $ cycle [False,False,True,True]
ghci> let y = toSeq $ cycle [False,True]
ghci> halfAdder x y
(F :~  F :~  F :~  T :~ ..., F :~  T :~  T :~  F :~ ...)
\end{verbatim}

Kansas Lava supports both simulation and synthesis of circuits by having a dual
shallow and deep embedding within \verb!Signal!. The deep embedding is a
structure of primitive entities that can be reified to a netlist, from which
we generate VHDL for compilation.

\subsection{In This Paper}

Programmatically generating hardware presents new challenges when it comes
to testing and debugging. Often, traditional lightweight testing strategies
are cumbersome to use in large circuits, or don't permit inspection of
intermediate values.

In this paper we present four approaches to testing and debugging
Lava circuits. They enable us to scale Lava usage to large, real-world
problem instances in a more straighforward manner than in the past.
We summarize each approach here, noting which embedding and
circuit type can be tested, as well as the target use case:

% TODO: Make sure this is correct
\begin{center}
\label{table:approaches}
\begin{tabular}{l | c | c | c | c | c | c |}
\cline{2-5}
& \multicolumn{2}{|c|}{Embedding}
& \multicolumn{2}{c|}{Circuit Type}
& \multicolumn{1}{|c}{}\\
\cline{2-6}
 & Shallow & Deep & Comb & Seq & Use Case \\
\hline
\multicolumn{1}{|c|}{QuickCheck} & \multirow{2}{*}{y} & \multirow{2}{*}{n} & \multirow{2}{*}{y} & \multirow{2}{*}{n} & \multirow{2}{*}{Users} \\
\multicolumn{1}{|c|}{\footnotesize{Section \ref{sec:quickcheck}}} & & & & & \\
\hline
\multicolumn{1}{|c|}{Truth Tables} & \multirow{2}{*}{y} & \multirow{2}{*}{n} & \multirow{2}{*}{y} & \multirow{2}{*}{y} & \multirow{2}{*}{Users} \\
\multicolumn{1}{|c|}{\footnotesize{Section \ref{sec:waveforms}}} & & & & & \\
\hline
\multicolumn{1}{|c|}{Probes} & \multirow{2}{*}{y} & \multirow{2}{*}{y} & \multirow{2}{*}{y} & \multirow{2}{*}{y} & \multirow{2}{*}{Both} \\
\multicolumn{1}{|c|}{\footnotesize{Section \ref{sec:probes}}} & & & & & \\
\hline
\multicolumn{1}{|c|}{Comparing} & \multirow{2}{*}{y} & \multirow{2}{*}{y} & \multirow{2}{*}{y} & \multirow{2}{*}{y} & \multirow{2}{*}{KL Devs} \\
\multicolumn{1}{|c|}{\footnotesize{Section \ref{sec:comparing}}} & & & & & \\
\hline
\end{tabular}

% took this out of a table \caption{Something}

\end{center}

\section{Using QuickCheck}
\label{sec:quickcheck}

A popular method of testing Haskell functions is to use the QuickCheck library.
Since Lava circuits are Haskell functions, this is straightforward.
For instance, given Kansas Lava's implementation of boolean conjunction and
a suitable instance of QuickCheck's Arbitrary typeclass:

\begin{verbatim}
and2 :: (Signal sig) => sig Bool -> sig Bool -> sig Bool
and2 = liftS2 $ \ (Comb a ae) (Comb b be) ->
                    Comb (liftA2 (&&) a b)
                       $ entity2 (Name "Bool" "and2") ae be

instance (Arbitrary a, Wire a) => Arbitrary (Comb a) where
    arbitrary = shallowComb <$> (optX :: Maybe a -> X a) <$> arbitrary
\end{verbatim}

One can verify properties like the following, which shows that the
\verb|and2| implementation is commutative:

\begin{verbatim}
prop_andComm x y = (x `and2` y) == (y `and2` x)
    where types = (x :: Comb Bool, y :: Comb Bool)
\end{verbatim}

While this approach is quick and easy to implement, it is of
limited use.

The most immediate problem is that equality over sequential
inputs is effectively undefined. While two sequences can certainly
be unequal, their unbounded nature makes it impossible to be
certain they are truly equivalent, rather than merely having
equivalent prefixes. We can use a hack to say, effectively, that
the first $n$ values are 'good enough':

\begin{verbatim}
prop_andCommSeq x y = show (x `and2` y) == show (y `and2` x)
    where types = (x :: Seq Bool, y :: Seq Bool)
\end{verbatim}

But this is less than ideal. An instance of QuickCheck's Arbitrary
typeclass is nevertheless defined for Seqs, in case it proves
useful for other kinds of tests.

More problematic is the fact that using QuickCheck doesn't test the deep
embedding at all. The instance that defines equality between
Comb values only compares the shallow embeddings. It is
not obvious how to define equality over the deep embedding,
short of comparing the resulting circuit graphs for isomorphism.
The worst case complexity of such a solution would be exponential.

As long as end users of Kansas Lava are building circuits out
of the supplied primitives, they shouldn't have to worry about
the deep embedding at all, so QuickCheck may prove to be an
effective tool for small circuits. For larger circuits that
require non-random inputs, another solution is needed.

\section{Generating Truth Tables and Waveforms}
\label{sec:waveforms}

An easy way to visualize the relationship between circuit inputs and
outputs is by generating truth tables, which can then be transformed
into waveform diagrams. For a combinatorial circuit, all possible
values for each input are permuted and the circuit is applied to each
permutation in turn, storing the result in a treelike structure.

This also works for sequential circuits. Using a small DSL to apply the sequential
circuit to sample inputs, we stash both the function and its arguments
in a data structure as they are applied in succession:

\begin{verbatim}
tt = truthTable (example (xor2 :: Seq Bool -> Seq Bool -> Seq Bool)
                .*. input1
                .*. input2)
        where
                input1 = encSeqBool "HLHHL"
                input2 = encSeqBool "HH_LL"
\end{verbatim}

Implementing this is straightforward. The \verb!example! function simply
wraps up its argument (the circuit) for the \verb!.*.! operator, which applies
each argument in succession, storing it for later inclusion in the table. Both
are defined thus:

\begin{verbatim}
data Example a = Example a [ExampleArg]

data ExampleArg = forall a . (Show a, RepWire a) => ExampleArg (Seq a)

example :: a -> Example a
example a = Example a []

infixl 2 .*.

(.*.) :: TestArg a => Example (a -> b) -> a -> Example b
(.*.) (Example f args) arg = Example (f arg) (args ++ testArg arg)

class TestArg a where
    testArg :: a -> [ExampleArg]
\end{verbatim}

All that remains is to pretty print the resulting truth table.
Currently we can output both ASCII and \LaTeX tables, as well as \LaTeX waveforms.
An example waveform for a mux can be found in Figure 1. % for some reason this returns 3?! \ref{fig:mux2}.
% is the use of the latex logo above totally retarded?

\begin{figure}
\label{fig:mux2}
\centering
\begin{tikztimingtable}
s0 & 1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U\\
i0 & 1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U\\
i1 & 1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U\\
o0 & 1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U\\
\end{tikztimingtable}

\caption{\tt mux2 :: Comb Bool $\to$ (Comb Bool, Comb Bool) $\to$ Comb Bool}
\end{figure}

Using this approach, it is easy to visualize the relationship
between inputs and outputs. In the case of sequential circuits, it is also
helpful to see \emph{when} things happen. As such, we intend to use it
extensively to document the behavior of Kansas Lava primitives for end users.

It also addresses one of the issues we had with QuickCheck, in that we have
control over the exact input that is used to test the circuit. This allows
us to more effectively test large circuits.

However, this approach requires direct examination by the user to verify that the
simulated circuit behaved correctly for each combination of inputs, which
is time consuming. It also doesn't test the deep embedding or permit
inspection of intermediate results inside the circuit. For larger circuits, this
ability is crucial. To address this need, we created probes.

\section{Circuit Instrumentation Using Probes}
\label{sec:probes}

Testing primitive circuits using the shallow embedding of Haskell provides a
convenient method for validating circuit behavior. However, as a Lava user
constructs increasingly larger components by composing primitive circuits, the shallow
embedding is of decreasing value for understanding the interaction between
those primitive components. This is due to the embedding of circuits as Haskell
values -- circuits are opaque Haskell functions with which it is only possible
to observe the relationship between inputs and function output. Intermediate
values, defined as local Haskell bindings, cannot be observed without modifying
the underlying circuit.

As a simple example, consider the archetypal Lava definition of a full adder,
constructed by combining two half adder circuits:

\begin{verbatim}
halfAdder a b = (sum,carry)
  where sum = xor2 a b
        carry = and2 a b

fullAdder a b cin = (sum,cout)
  where (s1,c1) = halfAdder a a
        (sum,c2) = halfAdder cin s1
        cout = xor2 c1 c2
\end{verbatim}

In this example, the intermediate values \verb!s1!, \verb!c1!, and \verb!c2! are
not exposed as outputs to the function, and are consequently not
obervable. In fact, the above definition has a bug in the calculation of
\verb!(s1,c1)! where the input parameter \verb!a! is used as the second argument
to the half adder instead of the parameter \verb!b!. Observing the input/output
behavior of the \verb!fullAdder! function will reveal incorrect behavior, but it
does not provide any insight into the location of the error. Rather, we need to
be able to observe the input/output behavior of the first \verb!halfAdder!.

One approach to locating the bug is to simply return the intermediate values as
additional outputs to the circuit:

\begin{verbatim}
fullAdder a b cin = ((sum,cout),debug)
  where (s1,c1) = halfAdder a a
        (sum,c2) = halfAdder cin s1
        cout = xor2 c1 c2
        debug = (s1,c1,c2)
\end{verbatim}

While effective, this approach suffers in that it changes the interface to the
circuit, which in turn necessitates a modification to all of the users of the
circuit. Moreover, if the incorrect behavior were to be observed when defining a
circuit which \emph{uses} the full adder, then that circuit must in turn be
modified to propogate the debugging output of the \verb!fullAdder! circuit.

This leaves the user with two options, both with
significant drawbacks. Either \emph{all} of the intermediate circuit outputs are
exported (changing the circuit interfaces a single time) and then the global
collection of intermediate values is sorted through, or the user 
iteratively exports a subset of the intermediate values, checking for correct
behavior, until the troublesome circuit is located.

Kansas Lava provides a solution that sidesteps this time consuming process
using the notion of a \emph{probe}. When using this construct,
intemediate values can be observed without changing the circuit
interface. Moreover, only those intermediate values that are probed will be
observable, allowing probes to be inserted and removed as the circuit is
searched to locate the source of an error.

The Kansas Lava \verb!probe! function takes a string representing a
user-significant name for the intermediate value and a Kansas Lava
circuit. To allow \verb!probe! to be utilized for a variety of types, the
function is overloaded via a type class. Instances are provided for the range of
types representable as Kansas Lava circuits.

\begin{verbatim}
class Probe a where
  probe :: String -> a -> a
\end{verbatim}

Using this function, we can instrument the \verb!fullAdder! circuit to expose
intermediate values:

\begin{verbatim}
fullAdder a b cin = (sum,cout)
  where (s1,c1) = halfAdder a a
        (sum,c2) = halfAdder cin (probe "s1" s1)
        cout = xor2 (probe "c1" c1) (probe "c2" c2)
\end{verbatim}

Kansas Lava provides two functions for extracting probe % had circuits instead of functions, is fns right?
values. First, \verb!probeCircuit! takes a circuit with probes and generates an
association list of probe names and values. The \verb!getProbe! function looks
up a probe name in this list and returns the associated value. The \verb!test!
function, shown below, demonstrates the use of these two functions.

\begin{verbatim}
test = do
  probes <- probeCircuit $ fullAdder' false false false
  case (getProbe probes "s1") of
    Just (ProbeValue probeName xstrm) -> return $ showXStream xstrm
\end{verbatim}

Calling \verb!test! at the ghci prompt yields the following trace of outputs for
the \verb!s1! probe: 

\begin{verbatim}
ghci> test
"F" :~  "F" :~  ...
\end{verbatim}

The probe mechanism automatically lifts combinational Kansas Lava
values into a stream of values.

While the above example demonstrated a way to observe intermediate Kansas
Lava values, it doesn't shed a great deal of light on the particular
bug in the full adder circuit. We have only observed the output of the
\verb!halfAdder!, whereas the bug is due to the incorrect input value.
To make it possible to observe both the input and output of a
function, we can apply \verb!probe! to the function itself:

\begin{verbatim}
fullAdder a b cin = (sum,cout)
  where (s1,c1) = (probe "h1" halfAdder) a a
        (sum,c2) = halfAdder cin s1
        cout = xor2 c1 c2
\end{verbatim}


Modifying the \verb!test! function allows us to print out the traces from all of
the probes.

\begin{verbatim}
test = do
  probes <- probeCircuit $ fullAdder'' false false false
  mapM_ printProbe probes
 where printProbe (i, (ProbeValue name xstrm)) = do
          putStr $ name ++ ": "
          putStrLn $ show $ showXStream xstrm
\end{verbatim}

This modified \verb!test! function shows the traces for each of the input
arguments to the half adder, as well as the output. The \verb!probe! function
generates names for each of these by simply enumerating each argument (along
with the result) and adding the enumerated index to the given probe name, \verb!h1!.

\begin{verbatim}
ghci> test
h1_2: "(F,F)" :~  "(F,F)"  :~ ...
h1_1: "F" :~  "F" :~  ...
h1_0: "F" :~  "F" :~  ...
\end{verbatim}

\paragraph{Implementing Probe}

The ability to observe intermediate Kansas Lava values is a pleasing consequence
of maintaining both a shallow and deep embedding of Kansas Lava
circuits. When the \verb!probe! function is invoked on the circuit, the
shallowly-embedded value associated with the circuit is stored in the deep
embedding. To allow any Kansas Lava value to be stored in the deep
representation, we construct an existential type, \verb!ProbeValue!, which has a
constraint which allows us to recover the printed representation of the
value. One downside of this implementation decision is that we can no longer
manipulate observed values directly, only their string representations.

Once probed values have been added to the deep embedding representation, 
\verb!probeCircuit! reifies the circuit using the basic Kansas Lava reification
mechanism \cite{}, and the stored probe values are copied to an association
list. Reificiation is performed within the IO monad, hence the use of monadic \verb!do!
notation in the \verb!test! functions.

% XXXXXX: Andrew, you should extend this to talk about how we can use this to
% make sure that the shallow embedding agrees with our generated VHDL for the same
% circuit, using testbench framework.

\section{Comparing Deep and Shallow}
\label{sec:comparing}

Using probes, we wrote a tool to compare the results of the shallow simulation
against those of the deep, compiled version of the circuit. This allows us to
confirm that the shallow and deep embeddings yield the same result.

\begin{verbatim}
testCircuit :: (Ports a, Probe a, Ports b) =>
		String -> a -> (a -> b) -> IO ()
\end{verbatim}

The \verb!testCircuit! function takes a probeable circuit (in this case \verb!mux2!) and
a function that applies the circuit to arguments. It simply wraps a probe around
the circuit and passes that to the second function. As an example:

\begin{verbatim}
testCircuit "mux2" 
    (mux2 :: Seq Bool -> (Seq U4, Seq U4) -> Seq U4)
    (\ f -> let sel  = toSeq $ cycle [True,False,True,True,False]
                inp  = toSeq $ cycle [0..15]
                inp2 = toSeq $ cycle $ reverse [0..15]
            in f sel (inp, inp2))  
\end{verbatim}

Using the data collected by the probe, we can generate input and expected output
files, along with a testbench, for a VHDL simulator. Using these, we test the
compiled VHDL obtained from the deep embedding and compare the results with 
a standard diff tool.

Using this basic ability to automatically compare the deep and shallow embeddings,
we can implement a form of algorithmic debugging, using one embedding as the
oracle for the other.

At a high level, algorithmic debugging builds an execution tree, then iteratively
checks the value of each node with one given by an oracle (often the programmer).
If the values match, the node is considered 'correct' and the debugger continues
with that node's siblings. If the values do not match, the debugger instead continues
with that node's children. If all the children are correct, then the node itself is
at fault.

% image of sample execution tree or circuit graph

Using the netlist created by the Kansas Lava reification process, we can construct
a small execution graph, where each node represents a high level component of
the circuit and contains the probe results for that component. We then search the
graph, simulating each node and comparing it to the probe results, returning
the first incorrect node that is either has no children, or has children that
are all correct.

% need to implement this and stick some code/pictures/dot diagrams here

This technique allows us to find problems in extremely large circuits quickly.

% talk about adapting probes to execution tree/algorithmic debugging idea?
% conclusion?
\section{Related Work}

\section{Conclusion and Future Work}

Traditional Haskell testing tools like QuickCheck are of limited use
when testing Lava circuits. Many properties that are easy to express
over finite data structures (like \verb!Comb!) are more cumbersome
over unbounded ones (such as \verb!Seq!). They also present no easy
way to test generated VHDL code.

Observing the inputs and outputs to a circuit via truth tables and
waveforms helps explain circuit behavior, but doesn't permit testing
of an internal component in the context of a larger circuit. Once again,
the deep embedding is not tested at all.

Probes present a method of observing intermediate values in the shallow
embedding and recovering them for comparison with the VHDL coming out of
the deep embedding. They also serve as the foundation for more advanced 
strategies, such as our adaptation of algorithmic debugging.

While the current system is primarily useful to Kansas Lava developers to
ensure correct VHDL generation, one possible future direction is to adapt 
the current framework to be a true algorithmic debugger, with the Lava
user as the oracle.

Alternatively, this framework could be used to test circuit optimizations,
using the unoptimized circuit as an oracle for the optimized one.
\bibliographystyle{splncs}
\bibliography{../../bib/csdl}

\end{document}
