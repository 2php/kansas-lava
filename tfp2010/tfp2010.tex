\documentclass{llncs}
\usepackage{tikz}
\usepackage{tikz-timing}
%

\begin{document}

\title{What's the Matter with Kansas Lava?}

\author{Andrew Farmer \and Garrin Kimmell \and Andy Gill}

\institute{
Information Technology and Telecommunication Center \\
Department of Electrical Engineering and Computer Science \\
The University of Kansas \\
2335 Irving Hill Road \\
Lawrence, KS 66045 \\
\email{\{anfarmer,kimmell,andygill\}@ku.edu}}

\maketitle

\begin{abstract}
Kansas Lava is a functional hardware description language implemented
in Haskell. In the course of attempting to generate ever larger circuits,
we have found the need to effectively test and debug the internals of
Kansas Lava. This includes confirming both the simulated behavior of the
circuit and its hardware realization via generated VHDL. In
this paper we share a few of our approaches to this problem, and discuss
the results of these efforts.
\end{abstract}

\section{Introduction}

\subsection{What is Kansas Lava?}

Kansas Lava is a domain specific language for hardware description.
Though there have been a number of previous implementations
of Lava, we have found the design space rich, with unexplored choices.
We use a direct (Chalmers style) specification of circuits, and make
significant use of Haskell overloading of standard classes, leading to
concise circuit descriptions. Kansas Lava supports both simulation (inside
GHCi), and execution via VHDL, by having a dual shallow and deep
embedding inside our Signal type. 

\subsection{Techniques}

In this paper we present four approaches to testing and debugging
Lava circuits. To summarize, with applicability:

\begin{table}
\label{table:approaches}

\begin{center}
\begin{tabular}{l | c | c | c | c | c | c |}
\cline{2-7}
& \multicolumn{2}{|c|}{Tests}
& \multicolumn{2}{|c|}{Circuit Type}
& \multicolumn{2}{|c|}{Helps} \\
\cline{2-7}
 & Shallow & Deep & Comb & Seq & Users & Developers \\
\hline
\multicolumn{1}{|l|}{QuickCheck} & y & n & y & n & y & n \\
\hline
\multicolumn{1}{|l|}{Truth Tables} & y & n & y & y & y & n \\
\hline
\multicolumn{1}{|l|}{Probes} & y & y & y & y & y & y \\
\hline
\multicolumn{1}{|l|}{Comparing} & y & y & y & y & y & y \\
\hline
\end{tabular}

\caption{Something}

\end{center}
\end{table}

\section{Using QuickCheck}

A popular method of testing Haskell functions is to use the QuickCheck library.
Since Lava circuits are Haskell functions, this is straightforward.
For instance, given Kansas Lava's implementation of boolean conjunction and
a suitable instance of QuickCheck's Arbitrary typeclass:

\begin{verbatim}
and2 :: (Signal sig) => sig Bool -> sig Bool -> sig Bool
and2 = liftS2 $ \ (Comb a ae) (Comb b be) ->
                    Comb (liftA2 (&&) a b)
                       $ entity2 (Name "Bool" "and2") ae be

instance (Arbitrary a, Wire a) => Arbitrary (Comb a) where
    arbitrary = shallowComb <$> (optX :: Maybe a -> X a) <$> arbitrary
\end{verbatim}

One can verify properties like the following, which shows that the
\verb|and2| implementation is commutative:

\begin{verbatim}
prop_andComm x y = (x `and2` y) == (y `and2` x)
    where types = (x :: Comb Bool, y :: Comb Bool)
\end{verbatim}

While this approach is quick and easy to implement, it is of
limited use.

The most immediate problem is that equality over sequential
inputs is effectively undefined. While two sequences can certainly
be unequal, their unbounded nature makes it impossible to be
certain they are truly equivalent, rather than merely having
equivalent prefixes. We can use a hack to say, effectively, that
the first $n$ values are 'good enough':

\begin{verbatim}
prop_andCommSeq x y = show (x `and2` y) == show (y `and2` x)
    where types = (x :: Seq Bool, y :: Seq Bool)
\end{verbatim}

But this is less than ideal. An instance of QuickCheck's Arbitrary
typeclass is nevertheless defined for Seqs, in case it proves
useful for other kinds of tests.

More problematic is the fact that using QuickCheck doesn't test the deep
embedding at all. The instance that defines equality between
Comb values only compares the shallow embeddings. It is
not obvious how to define equality over the deep embedding,
short of comparing the resulting circuit graphs for isomorphism.
The worst case complexity of such a solution would be exponential.

As long as end users of Kansas Lava are building circuits out
of the supplied primitives, they shouldn't have to worry about
the deep embedding at all, so QuickCheck may prove to be an
effective tool for small circuits. For larger circuits that
require non-random inputs, another solution is needed.

\section{Generating Truth Tables and Waveforms}

An easy way to visualize the relationship between circuit inputs and
outputs is by generating truth tables, which can then be transformed
into waveform diagrams. For a combinatorial circuit, all possible
values for each input are permuted and the circuit is applied to each
permutation in turn, storing the result in a treelike structure.
An example waveform for a mux can be found in Figure 1. % for some reason this returns 3?! \ref{fig:mux2}.

\begin{figure}
\label{fig:mux2}
\centering
\begin{tikztimingtable}
s0 & 1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U\\
i0 & 1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U\\
i1 & 1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U\\
o0 & 1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U\\
\end{tikztimingtable}

\caption{\tt mux2 :: Comb Bool $\to$ (Comb Bool, Comb Bool) $\to$ Comb Bool}
\end{figure}

This also works for sequential circuits. Using a small DSL to apply the sequential
circuit to sample inputs, we stash both the function and its arguments
in a data structure as they are applied in succession.

All that remains is to pretty print the resulting truth table.
Currently we can output both ASCII and \LaTeX tables, as well as \LaTeX waveforms.
% is the use of the latex logo above totally retarded?

The best part of this approach is that it is easy to visualize the relationship
between inputs and outputs. In the case of sequential circuits, it is also
helpful to see when things happen.

As can be seen above, it's also great for documentation purposes. This will
come in handy when documenting the behavior of primitive functions for Kansas
Lava users.

It also addresses one of the issues we had with QuickCheck, in that we have
control over the exact input that is used to test the circuit. This allows
us to more effectively test large circuits.

However, this approach once again doesn't test the deep embedding at all.
It also requires direct examination by the user to verify that the
simulated circuit behaved correctly for each combination of inputs, which
is time consuming.

\section{Circuit Instrumentation using Probes}

Testing primitive circuits using the shallow embedding of Haskell provides a
convenient method for validating circuit behavior. However, as a Lava user
constructs increasingly larger by composing primitive circuits, the shallow
embedding becomes of decreasing value for understanding the interaction between
those primitive components. This is due to the embedding of circuits as Haskell
values -- circuits are opaque Haskell functions with which it is only possible
to observe the relationship between inputs and function output. Intermediate
values, defined as local Haskell bindings, cannot be observed without modifying
the underlying circuit.

As a simple example, consider the archetypal Lava definition of a full adder,
constructed by combining two half adder circuits:

\begin{verbatim}
halfAdder a b = (sum,carry)
  where sum = xor2 a b
        carry = and2 a b

fullAdder a b cin = (sum,cout)
  where (s1,c1) = halfAdder a a
        (sum,c2) = halfAdder cin s1
        cout = xor2 c1 c2
\end{verbatim}


In this example, the intermediate values \verb!s1!, \verb!c1!, and \verb!c2! are
not exposed as outputs to the function, and are consequently not
obervable. In fact, the above definition has a bug in the calculation of
\verb!(s1,c1)! where the input parameter \verb!a! is used as the second argument
to the half adder instead of the parameter \verb!b!. Observing the input/output
behavior of the \verb!fullAdder! function will reveal incorrect behavior, but it
does not provide any insight into the location of the error. Rather, we need to
be able to observe the input/output behavior of the first \verb!halfAdder!.

One approach to locating the bug is to simply return the intermediate values as
additional outputs to the circuit:

\begin{verbatim}
fullAdder a b cin = ((sum,cout),debug)
  where (s1,c1) = halfAdder a a
        (sum,c2) = halfAdder cin s1
        cout = xor2 c1 c2
        debug = (s1,c1,c2)
\end{verbatim}

While effective, this approach suffers in that it changes the interface to the
circuit, which in turn necessitates a modification to all of the users of the
circuit. Moreover, if the incorrect behavior were to be observed when defining a
circuit which \emph{uses} the full adder, then that circuit must in turn be
modified to propogate the debugging output of the \verb!fullAdder!  circuit.

This forces the user is forced to make a choice in how to debug, both with
significant drawbacks. Either \emph{all} of the intermediate circuit outputs are
exported (changing the circuit interfaces a single time) and then the global
collection of intermediate values is sorted through. Alternatively, the user can
iteratively export a subset of the intermediate values, checking for correct
behavior, until the troublesome circuit is located.

Kansas Lava provides a solution to the difficulty that sidesteps both of these
challenges using the notion of a \emph{probe}. When using this construct,
intemediate values can be observed without changing the circuit
interface. Moreover, only those intermediate values that have probes on will be
observable, allowing probes to be inserted and removed as the circuit is
searched to locate the source of an error.

The Kansas Lava \verb!probe! function takes a string representing a
user-significant name for the intermediate value, along with a Kansas Lava
circuit. To allow \verb!probe! to be utilized for a variety of types, the
function is overloaded via a type class. Instances are provided for the range of
types representable as Kansas Lava circuits.

\begin{verbatim}
class  Probe a where
  probe :: String -> a -> a
\end{verbatim}

Using this function, we can instrument the \verb!fullAdder! circuit to expose
intermediate values:

\begin{verbatim}
fullAdder a b cin = (sum,cout)
  where (s1,c1) = halfAdder a a
        (sum,c2) = halfAdder cin (probe "s1" s1)
        cout = xor2 (probe "c1" c1) (probe "c2" c2)
\end{verbatim}

Kansas Lava provided an additional two circuits for extracting probe
values. First, \verb!probeCircuit! takes a circuit with probes and generates a
association list of probe names and values. The \verb!getProbe! function looks
up a probe name in this list and returns the associated value. The \verb!test!
function, shown below, demonstrates the use of these two functions.

\begin{verbatim}
test = do
  probes <- probeCircuit $ fullAdder' false false false
  case (getProbe probes "s1") of
    Just (ProbeValue probeName xstrm) -> return $ showXStream xstrm
\end{verbatim}

Calling \verb!test! at the ghci prompt yields the following trace of outputs for
the \texttt{s1} probe. The probe mechanism automatically lifts combinational Kansas Lava
values into a stream of values, as the probe mechanism proves particularly
useful when debugging sequential circuits.

\begin{verbatim}
ghci> test
"F" :~  "F" :~  ...
\end{verbatim}

Although the above example demonstrated a way to observe intermediate Kansas
Lava values, it doesn't necessarily shed a great deal of light on the particular
bug in the full adder circuit, which is due to providing the wrong argument to
the first halfAdder circuit, while we have only observed the output to that
function. To make it possible to observe both the input and output of a
function, we can apply probe to the funciton iself:

\begin{verbatim}
fullAdder a b cin = (sum,cout)
  where (s1,c1) = (probe "h1" halfAdder) a a
        (sum,c2) = halfAdder cin s1
        cout = xor2 c1 c2
\end{verbatim}


Modifying the \verb!test! function allows us to print out the traces from all of
the probes.

\begin{verbatim}
test = do
  probes <- probeCircuit $ fullAdder'' false false false
  mapM_ printProbe probes
 where printProbe (i, (ProbeValue name xstrm)) = do
          putStr $ name ++ ": "
          putStrLn $ show $ showXStream xstrm
\end{verbatim}

This modified \verb!test! function shows the traces for each of the input
argument to the half adder, as well as the output. The \verb!probe! function
generates names for each of these by simply enumerating each argument (along
with the result) and adding the enumerated index to the given probe name, h1.

\begin{verbatim}
ghci> test
h1_2: "(F,F)" :~  "(F,F)"  :~ ...
h1_1: "F" :~  "F" :~  ...
h1_0: "F" :~  "F" :~  ...
\end{verbatim}

\paragraph{Implementing Probe}

The ability to observe intermediate Kansas Lava values is a pleasing consequence
of maintaining both a shallow and deeply-embedded representation of Kansas Lava
circuits. When the \verb!probe! function is invoked on circuit, the
shallowly-embedded value associated with the circuit is stored in the deep
embedding. To allow any Kansas Lava value to be stored in the deep
representation, we construct an existential type, \verb!ProbeValue!, which has a
constraint which allows us to recover the printed representation of the
value. One downside of this implementation decision is that we can no longer
manipulate observed values directly, but rather as their string representations.

Once probed values have been added to the deep embedding representation, the
\verb!probeCircuit! reifies the circuit using the basic Kansas Lava reification
mechanism \cite{}, and the stored probe values are copied to an association
list. Reificiation performed within the IO monad, hence the use of monadic \verb!do!
notation in the \verb!test! functions.

XXXXXX: Andrew, you should extend this to talk about how we can use this to
make sure that the shallow embedding agrees with our generated VHDL for the same
circuit, using testbench framework.


Garrin can probably describe this better than I can.

Downside: Requires instrumenting code with calls to probe (although Garrin is close to
overcoming this I think).

\section{Comparing Deep and Shallow}

Describe, maybe show example or the info file or something?

\subsection{The Good}

Excellent for testing our VHDL generation.

\subsection{The Bad}

Not so useful to end users of Lava? Simulation can be time consuming?

% talk about adapting probes to execution tree/algorithmic debugging idea?
% conclusion?

\end{document}
