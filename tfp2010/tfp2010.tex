\documentclass{llncs}
\usepackage{tikz}
\usepackage{tikz-timing}
%

\begin{document}

\title{Some Title Here}
\subtitle{And Maybe a Subtitle Here}

\author{Andrew Farmer \and Tristan Bull \and Garrin Kimmell \and Andy Gill}

\institute{
Information Technology and Telecommunication Center \\
Department of Electrical Engineering and Computer Science \\
The University of Kansas \\
2335 Irving Hill Road \\
Lawrence, KS 66045 \\
\email{\{anfarmer,tbull,kimmell,andygill\}@ku.edu}}

\maketitle

\begin{abstract}
Kansas Lava is a functional hardware description language implemented
in Haskell. In the course of attempting to generate ever larger circuits
using Kansas Lava, we have found the need to effectively test and debug
both the simulated circuit and its hardware realization. In this paper
we share a few of our approaches to this problem, and discuss the
results of these efforts.
\end{abstract}

\section{What is Kansas Lava?}

Kansas Lava is a domain specific language for hardware description.
Though there have been a number of previous implementations
of Lava, we have found the design space rich, with unexplored choices.
We use a direct (Chalmers style) specification of circuits, and make
significant use of Haskell overloading of standard classes, leading to
concise circuit descriptions. Kansas Lava supports both simulation (inside
GHCi), and execution via VHDL, by having a dual shallow and deep
embedding inside our Signal type. We also have a lightweight sized-type
mechanism, allowing for MATLAB style matrix based specifications to
be directly expressed in Kansas Lava.

\section{Using QuickCheck}

Early on, we tried to leverage the popular QuickCheck library to gain some
assurances that our entities functioned correctly. We were able to, relatively
quickly, write properties that checked our primitives to ensure they
exhibited basic properties of boolean logic.

For instance, given our implementation of boolean conjunction:

\begin{verbatim}
and2 :: (Signal sig) => sig Bool -> sig Bool -> sig Bool
and2 = liftS2 $ \ (Comb a ae) (Comb b be) ->
                    Comb (liftA2 (&&) a b)
                       $ entity2 (Name "Bool" "and2") ae be
\end{verbatim}

We were able to verify properties like the following, which shows that our
\verb|and2| implementation is commutative:

\begin{verbatim}
prop_andComm x y = (x `and2` y) == (y `and2` x)
    where types = (x :: Comb Bool, y :: Comb Bool)
\end{verbatim}

While this approach was quick and easy to implement, it is of
limited use.

The biggest downside is that it doesn't test the deep
embedding at all. The instance that defines equality between
combinatorial values only compares the shallow values. It is
not obvious how we could define equality over the deep embedding,
short of comparing the resulting circuit graphs for isomorphism.
The worst case complexity of such a solution would be exponential.

This is not a big issue for users of Kansas Lava, but it presents
a problem for us, the developers. As long as users are building
circuits out of primitives we supply, they shouldn't have to
think about the deep embedding at all. We, on the other hand,
need some assurance that we are generating correct VHDL.

Another issue that does affect end users is generating valid test inputs. For
a small circuit like \verb|and2| or a half adder, this is
relatively straightforward. For a larger circuit like an LDPC
decoder, QuickCheck's semi-random inputs are not very useful.

\section{Generating Truth Tables and Waveforms}

Next, we tried to visualize our circuits by generating truth tables,
which can then be transformed into waveform diagrams. An
example waveform for a mux can be found in Figure 1. % for some reason this returns 3?! \ref{fig:mux2}.

\begin{figure}
\label{fig:mux2}
\centering
\begin{tikztimingtable}
s0 & 1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9L1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9H1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U\\
i0 & 1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U\\
i1 & 1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U\\
o0 & 1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9H1.9U1.9L1.9L1.9L1.9H1.9H1.9H1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U1.9U\\
\end{tikztimingtable}

\caption{\tt mux2 :: Comb Bool $\to$ (Comb Bool, Comb Bool) $\to$ Comb Bool}
\end{figure}

This currently works for both combinatorial and sequential circuits. In the
combinatorial case, we merely need the function that represents the circuit.
Using the type of this function, we generate all possible values for each
input and apply them in all possible combinations.

For sequential circuits, we must supply both the function and sample input
sequences. We wrap the function up in a data structure, and stash the arguments
in this data structure as we apply them in succession.

At this point, all that remains is to pretty print the resulting truth table.
Currently we can output both ASCII and \LaTeX tables, as well as \LaTeX waveforms.
% is the use of the latex logo above totally retarded?

The best part of this approach is that it is easy to visualize the relationship
between inputs and outputs. In the case of sequential circuits, it is also
helpful to see when things happen.

As can be seen above, it's also great for documentation purposes. This will
come in handy when documenting the behavior of primitive functions for Kansas
Lava users.

It also addresses one of the issues we had with QuickCheck, in that we have
control over the exact input that is used to test the circuit. This allows
us to more effectively test large circuits.

However, this approach once again doesn't test the deep embedding at all.
It also requires direct examination by the user to verify that the
simulated circuit behaved correctly for each combination of inputs, which
is time consuming.

\section{Circuit Instrumentation using Probes}

Testing primitive circuits using the shallow embedding of Haskell provides a
convenient method for validating circuit behavior. However, as a Lava user
constructs increasingly larger by composing primitive circuits, the shallow
embedding becomes of decreasing value for understanding the interaction between
those primitive components. This is due to the embedding of circuits as Haskell
values -- circuits are opaque Haskell functions with which it is only possible
to observe the relationship between inputs and function output. Intermediate
values, defined as local Haskell bindings, cannot be observed without modifying
the underlying circuit.

As a simple example, consider the archetypal Lava definition of a full adder,
constructed by combining two half adder circuits:

\begin{verbatim}
halfAdder a b = (sum,carry)
  where sum = xor2 a b
        carry = and2 a b

fullAdder a b cin = (sum,cout)
  where (s1,c1) = halfAdder a a
        (sum,c2) = halfAdder cin s1
        cout = xor2 c1 c2
\end{verbatim}


In this example, the intermediate values \verb!s1!, \verb!c1!, and \verb!c2! are
not exposed as outputs to the function, and are consequently not
obervable. In fact, the above definition has a bug in the calculation of
\verb!(s1,c1)! where the input parameter \verb!a! is used as the second argument
to the half adder instead of the parameter \verb!b!. Observing the input/output
behavior of the \verb!fullAdder! function will reveal incorrect behavior, but it
does not provide any insight into the location of the error. Rather, we need to
be able to observe the input/output behavior of the first \verb!halfAdder!.

One approach to locating the bug is to simply return the intermediate values as
additional outputs to the circuit:

\begin{verbatim}
fullAdder a b cin = ((sum,cout),debug)
  where (s1,c1) = halfAdder a a
        (sum,c2) = halfAdder cin s1
        cout = xor2 c1 c2
        debug = (s1,c1,c2)
\end{verbatim}

While effective, this approach suffers in that it changes the interface to the
circuit, which in turn necessitates a modification to all of the users of the
circuit. Moreover, if the incorrect behavior were to be observed when defining a
circuit which \emph{uses} the full adder, then that circuit must in turn be
modified to propogate the debugging output of the \verb!fullAdder!  circuit.

This forces the user is forced to make a choice in how to debug, both with
significant drawbacks. Either \emph{all} of the intermediate circuit outputs are
exported (changing the circuit interfaces a single time) and then the global
collection of intermediate values is sorted through. Alternatively, the user can
iteratively export a subset of the intermediate values, checking for correct
behavior, until the troublesome circuit is located.

Kansas Lava provides a solution to the difficulty that sidesteps both of these
challenges using the notion of a \emph{probe}. When using this construct,
intemediate values can be observed without changing the circuit
interface. Moreover, only those intermediate values that have probes on will be
observable, allowing probes to be inserted and removed as the circuit is
searched to locate the source of an error.

The Kansas Lava \verb!probe! function takes a string representing a
user-significant name for the intermediate value, along with a Kansas Lava
circuit. To allow \verb!probe! to be utilized for a variety of types, the
function is overloaded via a type class. Instances are provided for the range of
types representable as Kansas Lava circuits.

\begin{verbatim}
class  Probe a where
  probe :: String -> a -> a
\end{verbatim}

Using this function, we can instrument the \verb!fullAdder! circuit to expose
intermediate values:

\begin{verbatim}
fullAdder a b cin = (sum,cout)
  where (s1,c1) = halfAdder a a
        (sum,c2) = halfAdder cin (probe "s1" s1)
        cout = xor2 (probe "c1" c1) (probe "c2" c2)
\end{verbatim}

Kansas Lava provided an additional two circuits for extracting probe
values. First, \verb!probeCircuit! takes a circuit with probes and generates a
association list of probe names and values. The \verb!getProbe! function looks
up a probe name in this list and returns the associated value. The \verb!test!
function, shown below, demonstrates the use of these two functions.

\begin{verbatim}
test = do
  probes <- probeCircuit $ fullAdder' false false false
  case (getProbe probes "s1") of
    Just (ProbeValue probeName xstrm) -> return $ showXStream xstrm
\end{verbatim}

Calling \verb!test! at the ghci prompt yields the following trace of outputs for
the \texttt{s1} probe. The probe mechanism automatically lifts combinational Kansas Lava
values into a stream of values, as the probe mechanism proves particularly
useful when debugging sequential circuits.

\begin{verbatim}
ghci> test
"F" :~  "F" :~  ...
\end{verbatim}

Although the above example demonstrated a way to observe intermediate Kansas
Lava values, it doesn't necessarily shed a great deal of light on the particular
bug in the full adder circuit, which is due to providing the wrong argument to
the first halfAdder circuit, while we have only observed the output to that
function. To make it possible to observe both the input and output of a
function, we can apply probe to the funciton iself:

\begin{verbatim}
fullAdder a b cin = (sum,cout)
  where (s1,c1) = (probe "h1" halfAdder) a a
        (sum,c2) = halfAdder cin s1
        cout = xor2 c1 c2
\end{verbatim}


Modifying the \verb!test! function allows us to print out the traces from all of
the probes.

\begin{verbatim}
test = do
  probes <- probeCircuit $ fullAdder'' false false false
  mapM_ printProbe probes
 where printProbe (i, (ProbeValue name xstrm)) = do
          putStr $ name ++ ": "
          putStrLn $ show $ showXStream xstrm
\end{verbatim}

This modified \verb!test! function shows the traces for each of the input
argument to the half adder, as well as the output. The \verb!probe! function
generates names for each of these by simply enumerating each argument (along
with the result) and adding the enumerated index to the given probe name, h1.

\begin{verbatim}
ghci> test
h1_2: "(F,F)" :~  "(F,F)"  :~ ...
h1_1: "F" :~  "F" :~  ...
h1_0: "F" :~  "F" :~  ...
\end{verbatim}

\paragraph{Implementing Probe}

The ability to observe intermediate Kansas Lava values is a pleasing consequence
of maintaining both a shallow and deeply-embedded representation of Kansas Lava
circuits. When the \verb!probe! function is invoked on circuit, the
shallowly-embedded value associated with the circuit is stored in the deep
embedding. To allow any Kansas Lava value to be stored in the deep
representation, we construct an existential type, \verb!ProbeValue!, which has a
constraint which allows us to recover the printed representation of the
value. One downside of this implementation decision is that we can no longer
manipulate observed values directly, but rather as their string representations.

Once probed values have been added to the deep embedding representation, the
\verb!probeCircuit! reifies the circuit using the basic Kansas Lava reification
mechanism \cite{}, and the stored probe values are copied to an association
list. Reificiation performed within the IO monad, hence the use of monadic \verb!do!
notation in the \verb!test! functions.

XXXXXX: Andrew, you should extend this to talk about how we can use this to
make sure that the shallow embedding agrees with our generated VHDL for the same
circuit, using testbench framework.


Garrin can probably describe this better than I can.

Downside: Requires instrumenting code with calls to probe (although Garrin is close to
overcoming this I think).

\section{Comparing Deep and Shallow}

Describe, maybe show example or the info file or something?

\subsection{The Good}

Excellent for testing our VHDL generation.

\subsection{The Bad}

Not so useful to end users of Lava? Simulation can be time consuming?

% talk about adapting probes to execution tree/algorithmic debugging idea?
% conclusion?

\end{document}
